<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>DMA</title>

  	<link rel="stylesheet" href="templates/SyntaxHighlighter.css"></link>
	<link rel="stylesheet" href="templates/style.css">
	
	<script	src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
	<script language="javascript" src="templates/shCore.js"></script>
	<script language="javascript" src="templates/shBrushCpp.js"></script>
	<script language="javascript" src="templates/shBrushJScript.js"></script>
	<script language="javascript" src="templates/shBrushPhp.js"></script>
	<script language="javascript" src="templates/shBrushJava.js"></script>
	<script language="javascript" src="templates/shBrushXml.js"></script>
	<script language="javascript" src="templates/shBrushCss.js"></script>
	<script language="javascript" src="templates/shBrushObjectiveC.js"></script>
	
	<script language="javascript" src="templates/vimwiki.js"></script>
</head>


<body>
    <div class="navbar">
      <div class="navbar-container">
	  <a class="brand" href="index.html">NieNet</a>
	  <div class="nav-collapse">
		<ul class="nav">
		  <li><a href="index.html">主页</a></li>
		  <li><a href="about.html">关于</a></li>
		</ul>
	  </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="container">
	<div id="content">
	
<p>
DMA的英文拼写是“Direct Memory Access”，汉语的意思就是直接内存访问，是一种不经过CPU而直接从内存存取数据的数据交换模式。
</p>

<h2 id="toc_0.1">X86架构下的DMA</h2>
<p>
PIO模式下硬盘和内存之间的数据传输是由CPU来控制的；而在DMA模式下，CPU只须向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻了CPU资源占有率。DMA模式与PIO模式的区别就在于，DMA模式不过分依赖CPU，可以大大节省系统资源，二者在传输速度上的差异并不十分明显。
</p>

<p>
DMA模式又可以分为Single-Word DMA（单字节DMA）和Multi-Word DMA（多字节DMA）两种，其中所能达到的最大传输速率也只有16.6MB/s。 DMA 传送方式的优先级高于程序中断，两者的区别主要表现在对CPU的干扰程度不同。中断请求不但使CPU停下来，而且要CPU执行中断服务程序为中断请求服务，这个请求包括了对断点和现场的处理以及CPU与外设的传送，所以CPU付出了很多的代价；DMA请求仅仅使CPU暂停一下，不需要对断点和现场的处理，并且是由DMA控制外设与主存之间的数据传送，无需CPU的干预，DMA只是借用了一点CPU的时间而已。还有一个区别就是，CPU对这两个请求的响应时间不同，对中断请求一般都在执行完一条指令的时钟周期末尾响应，而对DMA的请求，由于考虑它的高效性，CPU在每条指令执行的各个阶段之中都可以让给DMA使用，是立即响应。　DMA主要由硬件来实现，此时高速外设和内存之间进行数据交换不通过CPU的控制，而是利用系统总线。DMA方式是I/O系统与主机交换数据的主要方式之一，另外还有程序查询方式和中断方式。
</p>

<p>
举个例子，PC ISA DMA 控制器拥有 8 个 DMA 通道，其中的7个通道是可以让PC的CPU所利用。每一个DMA通道有一个16位元 位址暂存器和一个 16 位元 计数暂存器。要初始化资料传输时，装置驱动程式一起设定 DMA 通道的位址和计数暂存器，以及资料传输的方向，读取或写入。然后指示 DMA 硬件开始这个传输动作。当传输结束的时候，装置就会以中断的方式通知 CPU。
</p>

<p>
"分散-收集"(Scatter-gather)DMA允许在一次单一的DMA处理中传输资料到多个内存区域。相当于把多个简单的DMA要求串在一起。再一次，这个动机是要减轻CPU的多次输出输入中断和资料复制任务。
</p>

<p>
DRQ意为DMA要求；DACK意为DMA确认。这些符号一般在有DMA功能的电脑系统硬件概要上可以看到。他们表示了介于CPU和DMA控制器之间的电子讯号传输线路。
</p>

<h3 id="toc_0.1.1">DMA的传送工作过程</h3>
<ol>
<li>
DMAC 发出DMA 传送请求；

<li>
DMAC 通过连接到CPU 的HOLD 信号向CPU 提出DMA 请求； 

<li>
CPU 在完成当前总线操作后会立即对DMA 请求做出响应，CPU 的响应包括两个方面： CPU 将控制总线、数据总线和地址总线浮空，即放弃对这些总线的控制权；CPU 将有效的HLDA 信号加到DMAC 上，以通知DMAC CPU 已经放弃了总线的控制权； 

<li>
CPU 将总线浮空，即放弃了总线控制权后，由DMAC 接管系统总线的控制权，并向外设送出DMA 的应答信号。 

<li>
DMAC 送出地址信号和控制信号，实现外设与内存或内存之间大量数据的快速传送。 

<li>
DMAC 将规定的数据字节传送完之后，通过向CPU 发HOLD 信号，撤消对CPU的DMA 请求。CPU 收到此信号，一方面使HLDA 无效，另一方面又重新开始控制总线，实现正常取指令、分析指令、执行指令的操作。 

</ol>

<h3 id="toc_0.1.2">DMA传输方式</h3>
<p>
DMA 的传送方式分为：I/O 接口到存储器，存储器到I/O 接口和存储器到存储器三种模式。
</p>
<ul>
<li>
1) I/O 接口到存储器方式 

</ul>
<p>
当进行由I/O 接口到存储器的数据传送时，来自I/O 接口的数据利用DMAC 送出的控 制信号，将数据输送到系统数据总线D0~D7 上，同时，DMAC 送出存储器单元地址及控 制信号，将存在于D0~D7 上的数据写入所选中的存储单元中。这样就完成了由I/O 接口到存储器一个字节的传送。同时DMAC 修改内部地址及字节数寄存器的内容。
</p>
<ul>
<li>
2) 存储器到 I/O 接口 

</ul>
<p>
与前一种情况类似，在进行这种传送时，DMAC 送出存储器地址及控制信号，将选中 的存储单元的内容读出放在数据总线D0~D7 上，接着，DMAC 送出控制信号，将数据写到规定的(预选中)端口中去，而后MDAC 自动修改内部的地址及字节数寄存器的内容。
</p>
<ul>
<li>
3) 存储器到存储器 

</ul>
<p>
存储器到存储器的DMA数据传送采用数据块传送方式，首先送出内存源区域的地址和 控制信号，将选中内存单元的的数据暂存，接着修改地址及字节数寄存器的值，然后输出内存目的区域的地址及控制信号，将暂存的数据，通过系统数据总线，写入到内存的目的区域中去，最后修改地址和字节数寄存器的内容，当字节计数器减到零或外部输入时可结束一次 DMA 传输过程。
</p>

<h2 id="toc_0.2">ARM/MIPS结构下的DMA</h2>
<p>
使用DMA的好处就是它不需要CPU的干预而直接服务外设，这样CPU就可以去处理别的事务，从而提高系统的效率，对于慢速设备，如UART，其作用只是降低CPU的使用率，但对于高速设备，如硬盘，它不只是降低CPU的使用率，而且能大大提高硬件设备的吞吐量。因为对于这种设备，CPU直接供应数据的速度太低。 
因CPU只能一个总线周期最多存取一次总线，而且对于ARM，它不能把内存中A地址的值直接搬到B地址。它只能先把A地址的值搬到一个寄存器，然后再从这个寄存器搬到B地址。也就是说，对于ARM，要花费两个总线周期才能将A地址的值送到B地址。而DMA就不同了，一般系统中的DMA都有突发（Burst）传输的能力，在这种模式下，DMA能一次传输几个甚至几十个字节的数据，所以使用DMA能使设备的吞吐能力大为增强。
使用DMA时我们必须要注意如下事实：
</p>
<ul>
<li>
DMA使用物理地址，程序是使用虚拟地址的，所以配置DMA时必须将虚拟地址转化成物理地址。

<li>
因为程序使用虚拟地址，而且一般使用CACHED地址，所以虚拟地址中的内容与其物理地址上的内容不一定一致辞，所以在启动DMA传输前一定要将该地址的CACHE刷新，即写入内存。

<li>
OS并不能保证每次分配到的内在空间在物理上是连续的。尤其是在系统使用过一段时间而又分配了一块比较大的内存时。所以每次都需要判断地址是不是连续的，如果不连续就需要把这段内存分成几段让DMA完成传输

</ul>

<h2 id="toc_0.3">S3C3410的DMA驱动分析</h2>
<p>
<a href="S3C3410的DMA驱动分析.html">S3C3410的DMA驱动分析</a>
</p>


<h2 id="toc_0.4">PIC32的DMA模块分析</h2>
<p>
<a href="PIC32的DMA模块分析.html">PIC32的DMA模块分析</a>
</p>

	</div>
    </div>

    <footer>
	<p id="legal">Copyright &copy; 2012 NIE-YONG. All Rights Reserved.</p>
    </footer>

    <a class="go2top" style="display: none;"><span></span></a>

</body>


<script language="javascript">
dp.SyntaxHighlighter.HighlightAll('code');
</script>

</html>

