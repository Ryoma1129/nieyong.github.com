<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>ble问题记录</title>

  	<link rel="stylesheet" href="templates/SyntaxHighlighter.css"></link>
	<link rel="stylesheet" href="templates/style.css">
	
	<script	src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
	<script language="javascript" src="templates/shCore.js"></script>
	<script language="javascript" src="templates/shBrushCpp.js"></script>
	<script language="javascript" src="templates/shBrushJScript.js"></script>
	<script language="javascript" src="templates/shBrushPhp.js"></script>
	<script language="javascript" src="templates/shBrushJava.js"></script>
	<script language="javascript" src="templates/shBrushXml.js"></script>
	<script language="javascript" src="templates/shBrushCss.js"></script>
	<script language="javascript" src="templates/shBrushObjectiveC.js"></script>
	
	<script language="javascript" src="templates/vimwiki.js"></script>
</head>


<body>
    <div class="navbar">
      <div class="navbar-container">
	  <a class="brand" href="index.html">NieNet</a>
	  <div class="nav-collapse">
		<ul class="nav">
		  <li><a href="index.html">主页</a></li>
		  <li><a href="about.html">关于</a></li>
		</ul>
	  </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="container">
	<div id="content">
	
<h2 id="toc_0.1">CoreBluetooth库接口断开还需等待60s才能够收到AD包</h2>
<p>
When you disconnect a device with cancelPeripheralConnection the didDisconnectPeripheral delegate method will be invoked. However from iOS 6.0 the device remains connected for about 40-50 seconds (or more), so no didDiscoverPeripheral will be invoked in that timeframe. If you want to "discover" it again just call the retrieveConnectedPeripherals method and you will get the reference in didRetrieveConnectedPeripherals.
</p>

<p>
However, the best solution is to save the device's UUID and use that to reconnect with the retrievePeripherals method. This will invoke didRetrievePeripherals and you can reconnect with connectPeripheral. This is the fastest way to reconnect to a device, no scanning is required in this case.
</p>

<p>
<a href="http://stackoverflow.com/questions/13286487/how-can-i-reconnect-to-device-after-disconnecting-in-core-bluetooth">http://stackoverflow.com/questions/13286487/how-can-i-reconnect-to-device-after-disconnecting-in-core-bluetooth</a>
</p>

<h2 id="toc_0.2">部分iPhone 4S搜索不到蓝牙主控的问题</h2>
<p>
一共测试了6台iphone 4s机器，其中5台机器测试可以连接到ble，1台不行。
</p>

<h4 id="toc_0.2.0.1">测试根据：</h4>
<p>
通过通信库代码跟踪，发现扫描不到主控，是因为无法连接成功，可以扫描到。具体的表现为在连接回调成功之后，立刻出现了断开连接的回调，导致无法进一步的交互。
</p>

<p>
所以测试的时候，只要能够连接成功，并且读出ble的device信息，那么我们就算该机器能够连接上ble并且扫描到主控。
</p>

<h4 id="toc_0.2.0.2">测试过程：</h4>
<p>
测试的6台机器都安装软件lightblue（或者那个付费软件），然后看是否能够连接到我们的主控。其中，有5台能够连接，1台无法连接；
</p>

<p>
在上面6台设备中，有3台拥有开发这权限，其中1台无法连接，另外两台可以；这也说明上面的测试方法是ok的。
</p>

<p>
5台能够连接的iphone 4s系统为6.0.1；不能够连接的设备系统为6.0，升级到6.0.1仍然不能够连接；
</p>

<p>
有另外几台iphone 4s设备，由于版本为6.0以下，提示不能够安装lightblue软件；
</p>

<h4 id="toc_0.2.0.3">测试结果以及分析：</h4>
<ul>
<li>
软件版本6.0以上是能够使用ble的必要条件；

<li>
软件版本6.0以上也可能会无法连接到ble设备；

<li>
导致无法连接的原因可能和ios的库，iphone 4s使用的蓝牙方案有关（iphone 4s和iphone 5是使用的不同蓝牙方案）。有这样的猜测，主要参考了iphone的一些邮件，尤其是<a href="http://lists.apple.com/archives/bluetooth-dev/2012/Nov/msg00031.html">Bluetooth LE problems with new iOS devices</a>。这个邮件中出现的情况和我们的相近，只是他们的是iphone 4s能够连上，而iphone 5不能够。在邮件中谈到主要的问题出在蓝牙外设的参数配置。由于我们没有抓包工具等调试手段，所以无法深入跟踪。另外，我们的固件也尝试了几种参数配置，那台不能够连接的iphone 4s仍然无法连接。

</ul>

<h3 id="toc_0.2.1">关于BLE通信问题的纪录</h3>

<p>
昨天测试了BLE通信的速度丢包问题
</p>

<p>
测试方式：
touch以100ms的间隔向主控发送通道数据包（34bytes），主控需要回复的ack报文有66bytes，这样，一个交互过程为100字节的数据量，这应该也是对BLE缓存区buffer的要求。通信速率也就在8kbit/s，或者1.5kbytes/s。
</p>

<p>
然后以125ms，160ms，200ms做同样的测试
</p>

<p>
测试结果：
</p>

<p>
在125ms和100ms的时候，出现了丢包的现象，也就是某些SN的报文没有回复，丢包的原因在于BLE接收到的某些包出现了错误。发包速度越快，丢包越严重。
</p>

<p>
在发送速度为100ms，125ms，160ms的时候，ack报文回复的速度不能够保证在改时间内收到。
</p>

<p>
一些结论和思考：
1.发送速度是引起丢包的原因；
2.丢包问题是由蓝牙接收到的数据有错误引起；
3.ack报文回复的速度（从发出某个SN的报文，到收到该SN报文）大概在130ms~180ms左右；
4.ack报文回复速度为200ms的原因尚未清楚：BLE的传输速率？BLE的处理速率？主控处理速率？can总线速率？等等
</p>


<p>
一些其他的异常问题：
在使用过程中，touch一直扫描不到主控，发现是在连接成功之后，无法发现蓝牙的service。最后，解决的办法是重启了设备的蓝牙，就一切ok。
</p>


<h3 id="toc_0.2.2">通道命令ack报文</h3>
<p>
55aa55aa 3e002839 001006cd a8000405 080f4632
37313038 32300000 0000010a e903000f 0000feff
01000000 18fc00e6 ff01e903 00e90300 4e0000e9
03000000 bbbd
</p>

<p>
一个ack报文的长度是66bytes。
</p>

<pre>
 send sn = 52
 encodedData = &lt;55aa55aa 1e000134 000f0600 80000000 00000000 00000000 00000000 00000000 bd48&gt;
 send sn = 53
 encodedData = &lt;55aa55aa 1e000135 000f0600 80000000 00000000 00000000 00000000 00000000 74c1&gt;
 [001] 当前发包的序号是：53;收到包序号:52
 send sn = 54
 encodedData = &lt;55aa55aa 1e000136 000f0600 80000000 00000000 00000000 00000000 00000000 3e53&gt;
 [001] 当前发包的序号是：54;收到包序号:53
 send sn = 55
 encodedData = &lt;55aa55aa 1e000137 000f0600 80000000 00000000 00000000 00000000 00000000 f7da&gt;
 [001] 当前发包的序号是：55;收到包序号:54
 send sn = 56
 encodedData = &lt;55aa55aa 1e000138 000f0600 80000000 00000000 00000000 00000000 00000000 b711&gt;
 [001] 当前发包的序号是：56;收到包序号:55
 send sn = 57
 encodedData = &lt;55aa55aa 1e000139 000f0600 80000000 00000000 00000000 00000000 00000000 7e98&gt;
 [001] 当前发包的序号是：57;收到包序号:56
 send sn = 58
 encodedData = &lt;55aa55aa 1e00013a 000f0600 80000000 00000000 00000000 00000000 00000000 340a&gt;
 [001] 当前发包的序号是：58;收到包序号:57
 send sn = 59
 encodedData = &lt;55aa55aa 1e00013b 000f0600 80000000 00000000 00000000 00000000 00000000 fd83&gt;
 [001] 当前发包的序号是：59;收到包序号:58
 send sn = 60
 encodedData = &lt;55aa55aa 1e00013c 000f0600 80000000 00000000 00000000 00000000 00000000 b126&gt;
 send sn = 61
 encodedData = &lt;55aa55aa 1e00013d 000f0600 80000000 00000000 00000000 00000000 00000000 78af&gt;
 send sn = 62
 encodedData = &lt;55aa55aa 1e00013e 000f0600 80000000 00000000 00000000 00000000 00000000 323d&gt;
 [001] 当前发包的序号是：62;收到包序号:61
 send sn = 63




encodedData = &lt;55aa55aa 1e000135 000f0600 80000000 00000000 00000000 00000000 00000000 74c1&gt;
send sn = 54
encodedData = &lt;55aa55aa 1e000136 000f0600 80000000 00000000 00000000 00000000 00000000 3e53&gt;
updatedValue = &lt;55aa55aa 3e002835 001006cd a8000405 080f4632&gt;
updatedValue = &lt;37313038 32300000 0000010a e903000f 0000feff&gt;
updatedValue = &lt;01000000 18fc00e6 ff01e903 00e90300 4e0000e9&gt;
updatedValue = &lt;03000000 12d155aa 55aa3e00 28360010 06cda800&gt;
[001] 当前发包的序号是：54;收到包序号:53
updatedValue = &lt;0405080f 46323731 30383230 00000000 010ae903&gt;
updatedValue = &lt;000f0000 feff0100 000018fc 00e6&gt;
send sn = 55
encodedData = &lt;55aa55aa 1e000137 000f0600 80000000 00000000 00000000 00000000 00000000 f7da&gt;
send sn = 56
encodedData = &lt;55aa55aa 1e000138 000f0600 80000000 00000000 00000000 00000000 00000000 b711&gt;
updatedValue = &lt;55aa55aa 3e002837 001006cd a8000405 080f4632&gt;
updatedValue = &lt;37313038 32300000 0000010a e903000f 0000feff&gt;
updatedValue = &lt;01000000 18fc00e6 ff01e903 00e90300 4e&gt;
updatedValue = &lt;0000e9&gt;
updatedValue = &lt;03000000 294755aa 55aa3e00 28380010 06cda800&gt;
updatedValue = &lt;0405080f 46323731 30383230 00000000 010ae903&gt;
updatedValue = &lt;000f0000 feff0100 000018fc 00e6ff01&gt;
updatedValue = &lt;e90300e9&gt;
send sn = 57
encodedData = &lt;55aa55aa 1e000139 000f0600 80000000 00000000 00000000 00000000 00000000 7e98&gt;
updatedValue = &lt;03004e00 00e90300 0000ae72&gt;
[001] 当前发包的序号是：57;收到包序号:56
send sn = 58
encodedData = &lt;55aa55aa 1e00013a 000f0600 80000000 00000000 00000000 00000000 00000000 340a&gt;
updatedValue = &lt;55aa55aa 3e002839 001006cd a8000405 080f4632&gt;
updatedValue = &lt;37313038 32300000 0000010a e903000f 0000feff&gt;
updatedValue = &lt;01000000 18fc00e6 ff01e903 00e90300 4e&gt;
updatedValue = &lt;0000e9&gt;
updatedValue = &lt;03000000 bbbd55aa 55aa3e00 283a0010 06cda800&gt;
[001] 当前发包的序号是：58;收到包序号:57
updatedValue = &lt;0405080f 46323731 30383230 00000000 010ae903&gt;
updatedValue = &lt;000f0000 feff0100 000018fc 00e6ff01 e9&gt;
updatedValue = &lt;0300e9&gt;
send sn = 59
encodedData = &lt;55aa55aa 1e00013b 000f0600 80000000 00000000 00000000 00000000 00000000 fd83&gt;
updatedValue = &lt;03004e00 00e90300 000095e4&gt;
[001] 当前发包的序号是：59;收到包序号:58
</pre>

<h2 id="toc_0.3">蓝牙问题报告2</h2>
<h3 id="toc_0.3.1">1.can总线无法发出数据的问题</h3>
<p>
dji的设计中，主控，蓝牙，电台等是挂在can总线上，所有的通信都是通过can总线；
</p>

<p>
测试了连续发包导致无法收到ack报文，ble蓝牙断开等问题
</p>

<p>
测试了touch连续发包（也就是调参软件的view等页面的通信需求），导致无法收到ack报文，ble断开的问题。结果是can总线上无法测试到主控发出的ack报文，但是ble通过can总线发给主控的信息仍然能够测到。
</p>

<p>
这样基本可以肯定是can总线，或者主控出了问题；暂时未找到导致该问题的原因；
</p>


<h3 id="toc_0.3.2">2.主控扫描失败率高的问题</h3>
<p>
在对某个蓝牙进行测试时，出现了扫描失败率高的问题，失败率达到30％以上；
</p>

<p>
该问题具体来说是在连接上ble之后，无法获取ble的device信息，导致无法扫描到主控；最后确定是ble蓝牙模块的问题，可能是该蓝牙的硬件设计，天线设计等问题，在以后的量产，封装设计等方面，肯定需要考虑和测试该问题；
</p>

<p>
在这里记下备忘；
</p>

<h3 id="toc_0.3.3">3.断开ble连接的问题</h3>

<p>
使用ios的库函数cancelPeripheralConnection断开一个主控的连接时，需要等待一段时间（5s以上），并且不一定能够成功。
</p>

<p>
dji工程师设计了另外一个断开的办法，直接对ble的特征（0x33ff）写入字符xp，由ble上的软件控制断开连接。
</p>

<p>
该方法已经写入了通信库中，但是如果出现上面2所提到的主控扫描失败率高的问题时，就可能再也无法断开该ble主控，需要等待使用ios库函数cancelPeripheralConnection来断开连接；
</p>


<h2 id="toc_0.4">蓝牙问题报告3</h2>
<p>
对于报告2中的“2.主控扫描失败率高的问题，3.断开ble连接的问题”的补充和修正：
</p>

<p>
今天将新的通信库继承到调参软件后测试发现，使用了dji工程师提供的断开方式之后（直接对ble的特征0x33ff写入字符xp），主控的连接失败率会很高。
</p>

<p>
调试发现，主控连接失败率高的原因还是出在无法获得device信息，和主控扫描失败率高存在同样的地方（ios的库级别）。
</p>

<p>
最后删除了对0x33ff特征的直接写。
</p>

<p>
一些结论和思考：
</p>
<ol>
<li>
出现该问题的原因猜测：ios的蓝牙库和蓝牙fireware的内部断开是重复的，可能导致了一些不可控制的问题。例如直接对特征0x33ff写入字符xp之后，ios库并不知道ble内部已经自动断开了，所以出现了问题；

<li>
建议我们的蓝牙模块的设计，参考了苹果公司发布的《Bluetooth Accessory Design Guidelines for Apple Products》；

</ol>

<h2 id="toc_0.5">AD中发送出设备名方案</h2>
<p>
我们现在的做法是扫瞄主控阶段，就连接上蓝牙，给主控发命令，获取设备名和密码，再断开蓝牙。
</p>

<p>
尝试一下新建一个代码分支或另外写一个测试程序，改成：
1. 蓝牙上电，蓝牙给主控发命令，获取设备名，并存储在内存。（谢鹏）
2. 蓝牙发AD包的时候，将设备名广播出去。（谢鹏）
3. iPhone扫描阶段不连接蓝牙，只把AD包中的设备名显示给用户。（聂勇）
</p>

<p>
我不知道这样改会不会对扫描成功率和连接成功率有帮助，请谢鹏和聂勇讨论并实验一下。
</p>

<p>
AD中一起发出的应该包括设备名，密码，hardwareID。如果只有设备名，那么无法进行自动登陆，保存密码等等操作。
</p>

<p>
AD包中只有128bit，16字节，在长度上可能有问题
</p>

<h3 id="toc_0.5.1">2.20</h3>
<p>
到现在，代码方面大概完成了40％的工作量。并且就现在的实现，由于扫描结束之后，只有主控的设备名（不唯一）一个信息，所以扫描连接时的某些逻辑无法实现，现在发现的主要有以下几个：
</p>
<ul>
<li>
无法在启动时自动连接到上次连接的主控；

<li>
修改主控名或者密码之后（例如对于一个新主控），必须重启主控；

<li>
在device list页面，只能够显示当前扫描到的主控，保存在云端的主控显示有问题；

<li>
在device list页面，只能够查看当前连接的主控的设备名和密码；

</ul>
<p>
请各位判断以上问题的要害程度。
</p>

<p>
个人看法：相比与无法多个设备同时扫描，可能会导致设备ble崩溃等问题，上面的问题可以暂时接收，继续现在的开发。
</p>

<p>
至于下周一能否拿这个新的ble方案公测，则需要看开发的进度。我们必须注意到，主控和iphone调参app都可以通过升级改正问题，但是ble模块上的固件应该无法做升级。
</p>

<h3 id="toc_0.5.2">2.22</h3>
<p>
到现在，新的ble库的开发已经结束，并且移植到iphone调参软件，并且交付李做进一步的测试。
</p>

<p>
在今天开发下午的开发中，遇到了ble无法重连的问题，跟进测试了整个下午，最后在谢鹏的帮助下解决。该问题的原因，谢鹏的邮件中提到“由于每个蓝牙设备有个硬件地址，在同一个有效范围内必须唯一，我改为程序产生随机数的方法，结果导致了这个问题。”。
</p>

<p>
新的ble方案还存在的已知问题有：连接上一个ble之后，ble立即就断开了该连接。该问题出现的概率低，但是对产品可能存在隐患。谢鹏正在跟进该问题。
</p>


<h2 id="toc_0.6">ble导致设备蓝牙模块奔溃的问题</h2>
<p>
查看了Apple Mailing List 中关于Bluetooth的所有邮件（2012一年以来），发现其他人也遇到的该问题。详见下面该邮件：
</p>

<p>
<a href="http://lists.apple.com/archives/bluetooth-dev/2012/Aug/msg00130.html">BTLE reconnection problems</a>
</p>


<p>
在邮件中使用“messing with the state of the BTLE stack”描述该问题。别人的回复中提到，反复的scan，connect，disconnect并不是corebluetooth库建议方式。其中提到了下面这两个视频。有点困难就是该视频没有字幕。
</p>

<p>
For more info, please see the two WWDC2012 talks about Core Bluetooth.
</p>


<p>
一些测试和结论：
</p>
<ul>
<li>
出现该问题的情况一般都发生在重连的过程中，确实和邮件中提到的一致；

<li>
按照我们现在的ble设计，扫瞄主控就必须连接它，获取用户名和密码，也就是回出现上面的scan－discover－connect设计问题；

<li>
谢鹏已经将设备名从AD中广播出来，我们也进行了简单的测试，如此将绕过上面的反复scan－discover－connect的过程；如果后续的开发顺利，ble通信计划在app第二次提交apple store时修改；同时，地面站也需要修改。

</ul>

<h2 id="toc_0.7">附件：邮件内容</h2>
<h3 id="toc_0.7.1">ASK by RAM</h3>
<p>
I repeatedly face connection problems where the only way to discover a BTLE device which is constantly advertising is to turn On/Off Bluetooth in the iPhone through settings or in rare cases restart the phone itself. My app runs in the background and is scanning for devices with a specific list of services and it works most of the time. With one of the BTLE devices were using we had some reliability issues so I have retry logic which will repeatedly attempt to connect to a recently discovered UUID for a short while before giving up, Iam not sure if this behavior is messing up the stack.
</p>

<p>
Is there a way to debug the discovery issue or any recommended steps to ensure we are not messing with the state of the BTLE stack [ like not doing repeated connection attempts etc ] ?
</p>

<h3 id="toc_0.7.2">ANSWER by Joakim</h3>
<p>
Hi Ram,
Let me see if I can help you.
</p>

<ul>
<li>
While in background mode, you will see get notified once if a new device comes within range.

<li>
If you got that notification while the app was in the foreground you may not get any notification when the app enters the background.

<li>
Connection request "pend" forever and will not timeout (they can be cancelled)

<li>
No need to scan for the device every time

<li>
You simply can connect to the device without scanning for it if you have previously connected to or paired with the device using it's UUID.

</ul>

<p>
For more info, please see the two WWDC2012 talks about Core Bluetooth.
</p>

<h3 id="toc_0.7.3">by RAM</h3>
<p>
Thanks for the reply. Much appreciated. I understand the below pointers about the BT api. The logic I use is scan forever, once a device is discovered stop scanning and connect to the device. Once the device disconnects, scan again. The retries to repeatedly connect is an aberration in my question [ please ignore it ]. The above loop of scan,connect,scan seems to cause a problem of no device being discovered unless I restart BT through the Settings app. Of course this is not a consistent problem, I have had it work for days before this happened but sometimes it will show up in hours during my development .
</p>

<p>
I am wondering if this is a known bug or are there anything I need to take special care about to avoid messing up the BT stack. I would also like to point out that the BTLE device I am using does follow the Apple Bluetooth guidelines for advertisement intervals and connection parameters.
</p>

<p>
Ram
</p>

<h3 id="toc_0.7.4">by Joakim</h3>
<p>
Hi Ram,
</p>

<p>
I suggest you only scan for the device the first time. After connecting to it the first time, simply just try to connect to it using it's UUID instead of scan-discover-connect.
</p>


<h2 id="toc_0.8">3.7</h2>
<p>
本人使用cc2540做ble外设，在开发iOS的App时，发现使用iphone 4S时，在信号弱时断开重连时，反复几次之后，发现导致整个手机无法再次获取到服务和特征（能够扫描，连接），而且同一个手机上所有的ble App都出现该问题，只有重启整个手机，就可以。该问题在iphone 5上没有出现。
</p>

<p>
重连的过程中，没有重新扫描，还是直接使用的原来的perpheril。
</p>

<h2 id="toc_0.9">3.8／iphone 4s在重连时ble奔溃</h2>
<h3 id="toc_0.9.1">问题描述：</h3>
<p>
使用iphone 4S时，在信号弱时断开重连时，反复几次断开重连之后，发现导致整个手机无法再连接上ble，具体表现为获取不到服务和特征（能够扫描，连接），而且同一个手机上所有的ble App都出现该问题，只有重启整个手机，才能够重新连接ble。该问题在iphone 5上没有出现。
</p>

<h3 id="toc_0.9.2">bug测试：</h3>
<p>
发现该问题在App的view页面最容易出现，在其他页面尚未重现。
</p>

<p>
写了一个测试的小程序，以1Hz的频率发送ping命令，没有发现该问题，如果在该程序中添加大量的通信命令，就回容易重现该bug。
</p>

<p>
在ble的群中也有人遇到该问题，但是也没有解决。
</p>

<h3 id="toc_0.9.3">分析：</h3>
<p>
上面的测试说明，导致该bug的可能条件是iphone和ble外设之间存在大的数据通信。
</p>

<h3 id="toc_0.9.4">现有的修改方案：</h3>
<ul>
<li>
优化ble库中ping命令的发送

<li>
优化App的view页面的命令发送，在同一时间只发送必需的命令

</ul>

<p>
以上修改之后，室内的测试，该bug出现的概率要小很多了。明天将进行室外的测试。
</p>

<h3 id="toc_0.9.5">存在的隐患：</h3>
<ul>
<li>
没有找到问题的根源所在（甚至没有查到出现该问题的代码位置和毕现方法）

<li>
数据量大，收报延迟的问题和信号弱有关，但是否都导致该问题

<li>
现在的修改方案并没有完全杜绝该bug的出现

</ul>

<p>
请李南宁和陈成确实是否添加FAQ页面。
</p>

	</div>
    </div>

    <footer>
	<p id="legal">Copyright &copy; 2012 NIE-YONG. All Rights Reserved.</p>
    </footer>

    <a class="go2top" style="display: none;"><span></span></a>

</body>


<script language="javascript">
dp.SyntaxHighlighter.HighlightAll('code');
</script>

</html>

