* 挂载ISO文件
#mount -o loop xxx.iso /mnt/media

* 创建一个用户
#useradd ny
#passwd ny

* 查找包含某字符串的文件
#find . -type f -name "*"|xargs grep help
在当前路径下的所有文件中查找包含help字符的文件。

* 批量文件编码转化
使用find命令找到所有需要转换的文件，然后使用-exec执行iconv命令单个转化。
{{{name="code" class="c"
#!/bin/bash
find . -type f -name "*.wiki" \
-exec ls '{}' \; \
-exec iconv -f gb2312 -t utf8 '{}' -o ../webutf/tmp.wiki \; \
-exec mv ../webutf/tmp.wiki ../webutf/'{}' \;
}}}

* 对C文件进行排版，在拷贝代码错乱的时候很有用。但是kr风格的C语言可能我们还有些不习惯，并不是公司的C语言规范标准。
#indent -kr main.c


== grep，egrep命令 ==
* grep NW datafile
解释：打印datafile中包含NW的行

* grep -i 'define END_RCV_RTN_CALL' -r  ./h/*
解释：递归查找h目录下含有所示字符串的文件，忽略大小写


* grep -i -F 'void * muxDevLoad' -r  ./src/*
解释：-F选项表示使用普通字符串匹配，不使用正则表达式

* grep -R "whatever you like" * |grep -v ".svn/*" 
解释： GNU Grep含有--exclude-dir选项，如果使用Unix Grep，没有该选项，则使用以上命令。这种方式是使用管道进行双层“过滤”，其中第二次grep使用了-v选项，即逆向匹配，打印出不匹配的行。

* grep '^[we]' datafile
打印datafile中以w或者e开头的行

* egrep '2\.?[0-9]' datafile
解释：打印所有这样的行：它包含一个2，后跟0个或者一个句号，然后跟一个数字。

