导入导出
#define CMDID_EXPORT       0x0292
#define CMDID_EXPORT_ACK   0x0293
 
// Export Command
     typedef struct tagExport
     {
         INT32U start_address;   // 请求的EEPROM起始地址
         INT32U length;              // 请求的长度(一般写)
     }export_body;
 
     typedef struct tagExportCommand
     {
         COMMON_HEADER header;
         export_body body;
     } SET_EXPORT, *PSET_EXPORT;
 
     typedef struct tagExportAck
     {
         INT32U start_address;   // 请求的EEPROM起始地址
         INT32U length;              // 请求的长度(一般写)
         INT8U  data[128];       // 数据
         INT8U  section_index;   // 0-31
         INT8U  data_checksum;
     }exportack_body;
 
     typedef struct tagAckExport
     {
         COMMON_HEADER header;
         INT8U  result;
         exportack_body body;
     } ACK_EXPORT, *PACK_EXPORT;
 
 
 
 
 
 
#define CMDID_IMPORT       0x0294
#define CMDID_IMPORT_ACK   0x0295
     // Import command
     typedef struct tagImport
     {
         INT32U start_address;   // 请求的EEPROM起始地址
         INT32U length;              // 请求的长度(一般写)
         INT8U  data[128];       // 数据
         INT8U  section_index;   // 0-31
         INT8U  data_checksum;
     }import_body;
 
     typedef struct tagSetImport
     {
         COMMON_HEADER header;
         import_body body;
 
     } SET_IMPORT, *PSET_IMPORT;
 
 
     typedef struct tagImportAck
     {
         INT32U start_address;   // 请求的EEPROM起始地址
         INT32U length;              // 请求的长度(一般写)
     }importack_body;
 
     typedef struct tagAckImport
     {
         COMMON_HEADER header;
         INT8U  result;
         importack_body body;
 
     } ACK_IMPORT, *PACK_IMPORT;
 
需要配置的数据：
 
ConfigureExtName = "wkm";  //导入导出前需要判断是wkm的后缀才进行导入导出
     m_EPPROMSection = 0x20;
     m_startaddress = 0x0000;
 
 
 
 
     Firmwareversion_Minor = 0x05;
     Firmwareversion_Update = 0x08;
     SoftwareCode = 20110323;
     EEPROM_DATA_LENGTH =  130；
 
导出流程：
 
包头数据:SoftwareCode(INT32U), Firmwareversion_Minor(INT8U), Firmwareversion_Update(INT8U)
 
然后用CMDID_EXPORT命令请求导出包：
第一个包：
     _Export.body.start_address = m_startaddress;
     _Export.body.length = 128;
收到ack后处理：
把ack中的以下3个字段的数据拼到包头后面
          INT8U  data[128];       // 数据
         INT8U  section_index;   // 0-31
         INT8U  data_checksum;   //主控自行校验
 
收到ack之后请求剩余包的数据：
 
     _Export.body.start_address = (exportack.section_index+1)*128;
     _Export.body.length = 128;
 
当收到的ack的start_address
     if( exportack.start_address == m_startaddress+0x80*(m_EPPROMSection-1))
则判断为包已经收完了。
 
导入流程：
 
解出包头：
SoftwareCode(INT32U), Firmwareversion_Minor(INT8U), Firmwareversion_Update(INT8U)
 
解包头：
INT8U m_verMinor;
     INT8U m_verUpdate;
     INT32U m_Signature;
     dataStream >> m_Signature;
     dataStream >> m_verMinor;
     dataStream >> m_verUpdate;
 
if (m_Signature != SoftwareCode           ||
         m_verMinor != Firmwareversion_Minor  ||
         m_verUpdate != Firmwareversion_Update)
     {
         QMessageBox msgBox(QMessageBox::Information, tr("Info"), tr("Configuration file version does not match."), QMessageBox::Ok,g_pMainFrame);
    
     }
     Else
｛
     校验通过，开始导入
第一个包：
 
_Import.body.start_address = m_startaddress;
     _Import.body.length = 128;
for (int m=0; m<EEPROM_DATA_LENGTH; m++) {
         dataStream >> _Import.body.data[m];
          }
//取出130个字节，写入
 
     devIo().Write(&_Import,sizeof(_Import));
 
收到ack之后写入剩余包的数据：
     _Import.body.start_address = importack.start_address+128;
     _Import.body.length = 128;
for (int m=0; m<EEPROM_DATA_LENGTH; m++) {
         dataStream >> _Import.body.data[m];
     }
 
     devIo().Write(&_Import,sizeof(_Import));
 
 
当收到的ack的start_address
if( importack.start_address == m_startaddress+0x80*(m_EPPROMSection-1))
则判断为包已经收完了。
 
     如果ack.result ==0,则表示写eprom失败，提示导出失败
 
 
｝  
